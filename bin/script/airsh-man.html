<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>



<ul id="index">
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#PUREDATA-gpp-air-coremixer-ELEMENT">PUREDATA gpp-air-coremixer ELEMENT</a></li>
  <li><a href="#AIRMIX-::-AIR-CORE-MIXER-OSC-COMMAND-PROTOCOL">AIRMIX :: AIR CORE MIXER OSC COMMAND PROTOCOL</a>
    <ul>
      <li><a href="#CHANNEL-ADDRESSING">CHANNEL ADDRESSING</a></li>
    </ul>
  </li>
  <li><a href="#MONITORING">MONITORING</a>
    <ul>
      <li><a href="#ch-mon-ch-nom">&lt;ch&gt; mon / &lt;ch&gt; nom</a></li>
      <li><a href="#mix-xim">mix / xim</a></li>
      <li><a href="#con-noc">con / noc</a></li>
    </ul>
  </li>
  <li><a href="#CONTROLLERS">CONTROLLERS</a>
    <ul>
      <li><a href="#master-m-fader-f-level-airliner_vector">master|m fader|f|level &lt;airliner_vector&gt;</a></li>
      <li><a href="#master-m-lfader-rfader-left-right-airliner_vector">master|m lfader|rfader|left|right &lt;airliner_vector&gt;</a></li>
      <li><a href="#ch-fader-f-airliner_vector">&lt;ch&gt; fader|f &lt;airliner_vector&gt;</a></li>
      <li><a href="#ch-pan-p-airliner_vector">&lt;ch&gt; pan|p &lt;airliner_vector&gt;</a></li>
    </ul>
  </li>
  <li><a href="#AIRLINER_VECTOR">AIRLINER_VECTOR</a>
    <ul>
      <li><a href="#airliner_vector-examples">&lt;airliner_vector&gt; examples</a></li>
    </ul>
  </li>
  <li><a href="#AUDIO-PRODUCTION-PROCESSING-TOOLS">AUDIO PRODUCTION / PROCESSING TOOLS</a>
    <ul>
      <li><a href="#PLAY">PLAY</a></li>
      <li><a href="#LOOP">LOOP</a></li>
      <li><a href="#RECORD">RECORD</a></li>
    </ul>
  </li>
  <li><a href="#COMPLEX-CHANNEL-ADDRESSING">COMPLEX CHANNEL ADDRESSING</a></li>
  <li><a href="#GLOBAL-AND-PER-TRACK-ALIASES">GLOBAL AND PER-TRACK ALIASES</a></li>
  <li><a href="#INTERNAL-CLIENT--COMMANDS">INTERNAL CLIENT- COMMANDS</a></li>
  <li><a href="#AIRMON-::-AIR-CORE-MONITORING-OSC-COMMAND-PROTOCOL">AIRMON :: AIR CORE MONITORING OSC COMMAND PROTOCOL</a>
    <ul>
      <li><a href="#MONITORING-TACTICS">MONITORING TACTICS</a></li>
      <li><a href="#OSC-CONTROLLER-MAP">OSC CONTROLLER MAP</a>
        <ul>
          <li><a href="#MONITORING-TACTICS1">MONITORING TACTICS:</a></li>
          <li><a href="#ALL-THE-REST">ALL THE REST</a></li>
          <li><a href="#DIRECT-SYS-PARAMS">DIRECT SYS PARAMS</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#TWO-MAIN-SERVER-SIDE-MONITORING-MODES-BASED-ON-DIFFERENT-MONITORING-TACTICS">TWO MAIN SERVER-SIDE MONITORING MODES BASED ON DIFFERENT MONITORING TACTICS</a></li>
  <li><a href="#AIRSH-EXAMPLES">AIRSH EXAMPLES</a></li>
  <li><a href="#MON-OSC-PROTOCOL-EXAMPLES">MON OSC PROTOCOL EXAMPLES</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<p><b>airsh</b> :: AIR shell, a simple air-coremix.pd control shell to demonstrate OSC parameters to control the AIR core mixer | <b>B-AIR project Creative Europe 2020-2023</b></p>

<h1 id="PUREDATA-gpp-air-coremixer-ELEMENT"><b>PUREDATA gpp-air-coremixer ELEMENT</b></h1>

<p>OSC-controlled puredata core mixer for AIR platform:</p>

<p>[ gpp-air-coremixer.pd &lt;num.input.channels&gt; &lt;OSC.inaddress&gt; &lt;OSC.outaddress&gt; ]</p>

<p>Air core mixer automatically connects to the puredata input [adc~] and output [dac~]. Mixer output is stereo, while number of the input channels can be user-defined (as a fixed param 1 of the pd element). The params 2 and 3 are OSC input/output ports.</p>

<h1 id="AIRMIX-::-AIR-CORE-MIXER-OSC-COMMAND-PROTOCOL">AIRMIX :: AIR CORE MIXER OSC COMMAND PROTOCOL</h1>

<h2 id="CHANNEL-ADDRESSING">CHANNEL ADDRESSING</h2>

<p>The structure of the OSC message is:</p>

<p><b>/airmix/&lt;channel&gt;/&lt;controller&gt; argument(s)</b></p>

<p>channel = master (in short: m) or &lt;channel&gt; / &lt;set of channels&gt; - see <b>COMPLEX CHANNEL ADDRESSING</b></p>

<h1 id="MONITORING">MONITORING</h1>

<h2 id="ch-mon-ch-nom">&lt;ch&gt; <b>mon</b> / &lt;ch&gt; <b>nom</b></h2>

<p>local per-channel monitoring</p>

<h2 id="mix-xim"><b>mix / xim</b></h2>

<p>show whole mixer-monitor in a pd window</p>

<h2 id="con-noc"><b>con / noc</b></h2>

<p>inform client (console) to show or hide console gui window</p>

<h1 id="CONTROLLERS">CONTROLLERS</h1>

<h2 id="master-m-fader-f-level-airliner_vector"><b>master|m</b> <b>fader|f|level</b> &lt;airliner_vector&gt;</h2>

<p>send an <b>airliner_vector</b> to a master fader (both channels)</p>

<h2 id="master-m-lfader-rfader-left-right-airliner_vector"><b>master|m</b> <b>lfader|rfader|left|right</b> &lt;airliner_vector&gt;</h2>

<p>send an <b>airliner_ector</b> to a master fader (separate channels)</p>

<h2 id="ch-fader-f-airliner_vector">&lt;ch&gt; <b>fader|f</b> &lt;airliner_vector&gt;</h2>

<p>send an <b>airliner_ector</b> to a separate channel&#39;s faders</p>

<h2 id="ch-pan-p-airliner_vector">&lt;ch&gt; <b>pan|p</b> &lt;airliner_vector&gt;</h2>

<p>send an <b>airliner_vector</b> to a separate channel pan</p>

<p>* <b>NOTE</b> master has no pan but both faders /stereo/ instead</p>

<h1 id="AIRLINER_VECTOR"><b>AIRLINER_VECTOR</b></h1>

<p>is managed by gpp-airliner~.pm. Airliner can be bound to any mixer param, currently it controls <b>faders</b> and <b>panning</b></p>

<p>it will accept 1 - 4 input parameters:</p>

<p>&lt;<b>value_to_reach [rms 0-1]</b>&gt; &lt;<b>time_of_operation [ms]</b>&gt;<b>?</b> &lt;<b>curve [string - see below]</b>&gt;<b>?</b> &lt;<b>initial delay [ms]</b>&gt;<b>?</b></p>

<p>where only the first parameter, &lt;<b>value_to_reach [rms 0-1]</b>&gt;, is compulsory. The other three, if omitted, will default to:</p>

<dl>

<dt id="time_of_operation-ms-defaults-to-jump-micro-fader-time-50-ms">&lt;<b>time_of_operation [ms]</b>&gt; defaults to &#39;jump&#39; micro-fader time (50 ms)</dt>
<dd>

</dd>
<dt id="curve-see-defaults-to-lin-or-linear">&lt;<b>curve [see]</b>&gt; defaults to &#39;lin&#39; or &#39;linear&#39;</dt>
<dd>

</dd>
<dt id="initial-delay-ms-defaults-to-0">&lt;<b>initial delay [ms]</b>&gt; defaults to 0</dt>
<dd>

</dd>
</dl>

<p>Currently available curves:</p>

<dl>

<dt id="jump-micro-fader-50ms-linear-curve"><b>jump</b> micro-fader (50ms) linear curve</dt>
<dd>

</dd>
<dt id="lin-linear"><b>lin</b> linear</dt>
<dd>

</dd>
<dt id="sin-sinusoidal-soft"><b>sin</b> sinusoidal (soft)</dt>
<dd>

</dd>
<dt id="hsin-half-sinusoidal-equal-power"><b>hsin</b> half-sinusoidal (equal power)</dt>
<dd>

</dd>
<dt id="log-logarithmic-hard-neck"><b>log</b> logarithmic, hard neck</dt>
<dd>

</dd>
<dt id="pow-power-exponential-slow-sudden-attack"><b>pow</b> power (exponential), slow sudden attack</dt>
<dd>

</dd>
</dl>

<h2 id="airliner_vector-examples">&lt;airliner_vector&gt; examples</h2>

<dl>

<dt id="jump-to-0.9"><b>0.9</b> =&gt; jump to 0.9</dt>
<dd>

</dd>
<dt id="slide-to-0.422-in-7.5-seconds"><b>0.422 7500</b> =&gt; slide to 0.422 in 7.5 seconds</dt>
<dd>

</dd>
<dt id="sin-slide-to-1-in-4.23-seconds-following-sinusoidal-curve"><b>1 4230 sin</b> =&gt; slide to 1 in 4.23 seconds following sinusoidal curve</dt>
<dd>

</dd>
<dt id="pow-2000-slide-to-.5-in-7.6-seconds-following-power-curve-but-start-after-2-seconds-from-now"><b>0.5 7600 pow 2000</b> =&gt; slide to .5 in 7.6 seconds following power curve, but start after 2 seconds from now</dt>
<dd>

</dd>
</dl>

<h1 id="AUDIO-PRODUCTION-PROCESSING-TOOLS">AUDIO PRODUCTION / PROCESSING TOOLS</h1>

<h2 id="PLAY"><b>PLAY</b></h2>

<p>&lt;ch&gt; play &lt;file&gt;</p>

<p>Play a file (wav,aiff)</p>

<p>&lt;ch&gt; play &lt;file&gt; &lt;hh:mm:ss.uuu&gt;</p>

<p>Play a <b>file</b> from the selected <b>timing</b> on</p>

<p>&lt;ch&gt; play &lt;file&gt; &lt;hh:mm:ss.uuu&gt; &lt;hh:mm:ss.uuu&gt;</p>

<p>Play a <b>file</b> from the selected <b>timing</b> to the selected <b>end</b></p>

<p>&lt;ch&gt; play &lt;file&gt; &lt;hh:mm:ss.uuu&gt; &lt;hh:mm:ss.uuu&gt; +&lt;hh:mm:ss.uuu&gt;</p>

<p>Play a <b>file</b> from the selected <b>timing</b> to the selected <b>end</b> with the selected <b>+delay</b>. Note that the player / looper delay parameter should be marked with <b>+</b></p>

<p>&lt;ch&gt; stop</p>

<p>Stop current playing session at the addressed track</p>

<h2 id="LOOP"><b>LOOP</b></h2>

<p>&lt;ch&gt; loop &lt;file&gt;</p>

<p>Loop whole <b>file</b></p>

<p>&lt;ch&gt; loop &lt;file&gt; &lt;hh:mm:ss.uuu&gt; &lt;hh:mm:ss.uuu&gt;</p>

<p>Loop <b>file clip</b> from selected <b>timing</b> to selected <b>timing</b></p>

<p>&lt;ch&gt; loop &lt;file&gt; &lt;hh:mm:ss.uuu&gt; &lt;hh:mm:ss.uuu&gt; +&lt;hh:mm:ss.uuu&gt;</p>

<p>Loop <b>file clip</b> from selected <b>timing</b> to selected <b>timing</b> with intermediate <b>+delay</b></p>

<p>&lt;ch&gt; stop</p>

<p>Stop current looping session at the addressed track</p>

<h2 id="RECORD"><b>RECORD</b></h2>

<p>&lt;ch&gt; record &lt;file&gt;</p>

<p>Record to <b>file</b></p>

<p>&lt;ch&gt; record &lt;file&gt; &lt;hh:mm:ss.uuu&gt;</p>

<p>Record to <b>file</b> after initial <b>+delay</b></p>

<p>&lt;ch&gt; record &lt;file&gt; &lt;hh:mm:ss.uuu&gt; &lt;hh:mm:ss.uuu&gt;</p>

<p>Record to <b>file</b> after initial <b>lead-in</b> till selected <b>end</b>. The second figure being absolute time, not a time interval. Timing display will change color to red when the recording actually starts.</p>

<p>&lt;ch&gt; rstop</p>

<p>Stop current recording session at the addressed track</p>

<h1 id="COMPLEX-CHANNEL-ADDRESSING"><b>COMPLEX CHANNEL ADDRESSING</b></h1>

<p>&lt;ch&gt; can be defined as:</p>

<dl>

<dt id="channel-number-:-send-to-a-selected-channel-1-n"><b>channel number</b> : send to a selected channel 1-n</dt>
<dd>

</dd>
<dt id="all-:-send-to-all-channels"><b>all</b> : send to all channels</dt>
<dd>

</dd>
<dt id="even-:-send-to-even-numbered-channels"><b>even</b> : send to even-numbered channels</dt>
<dd>

</dd>
<dt id="odd-:-send-to-odd-numbered-channels"><b>odd</b> : send to odd-numbered channels</dt>
<dd>

</dd>
<dt id="selection-span-:-send-to-a-selection-span-which-consist-from---delimited-ranges-and-delimited-lists-for-instance-1-3-5-7"><b>selection span</b> : send to a selection span which consist from &#39;-&#39; delimited ranges and &#39;,&#39; delimited lists, for instance <b>1,3,5-7</b></dt>
<dd>

</dd>
</dl>

<h1 id="GLOBAL-AND-PER-TRACK-ALIASES"><b>GLOBAL AND PER-TRACK ALIASES</b></h1>

<dl>

<dt id="ch-solo-:-set-the-channel-solo"><b>ch</b> <b>solo</b> : set the channel &#39;solo&#39;</dt>
<dd>

</dd>
<dt id="ch-mute-m-:-mute-the-channel-monitoring:-airmon-etc-mute-1"><b>ch</b> <b>mute</b> | <b>m</b> : mute the channel (monitoring: /airmon/etc/mute 1 )</dt>
<dd>

</dd>
<dt id="ch-unmute-um:-mute-the-channel-monitoring:-airmon-etc-mute-0"><b>ch</b> <b>unmute</b> | <b>um</b>: mute the channel (monitoring: /airmon/etc/mute 0 )</dt>
<dd>

</dd>
<dt id="master-ml-mr-:-mute-left-master-or-right-master-channel"><b>master</b> <b>ml</b> | <b>mr</b> : mute left master or right master channel</dt>
<dd>

</dd>
<dt id="master-uml-umr-:-mute-left-master-or-right-master-channel"><b>master</b> <b>uml</b> | <b>umr</b> : mute left master or right master channel</dt>
<dd>

</dd>
<dt id="panic-:-all-track-faders-set-to-0"><b>panic</b> : all track faders set to 0</dt>
<dd>

</dd>
<dt id="dir-cd-:-set-global-wavedata-directory"><b>dir</b> | <b>cd</b> : set global wavedata directory</dt>
<dd>

</dd>
<dt id="ls-:-get-global-wavedata-directory"><b>ls</b> : get global wavedata directory</dt>
<dd>

</dd>
<dt id="trimfader-:-set-trimfader-time-or-trimfader-type-not-yet-implemented"><b>trimfader</b> : set <b>trimfader time</b> or <b>trimfader type</b> <b>[ *not yet implemented ]</b></dt>
<dd>

</dd>
<dt id="centerpan-:-center-all-pans"><b>centerpan</b> : center all pans</dt>
<dd>

</dd>
<dt id="fullout-:-set-all-faders-to-full"><b>fullout</b> : set all faders to full</dt>
<dd>

</dd>
<dt id="stereopan-:-set-even-numbered-faders-to-0-and-odd-numbered-faders-to-1-receiving-in-full-stereo-mode-not-yet-implemented"><b>stereopan</b> : set even-numbered faders to 0 and odd-numbered faders to 1 (receiving in full stereo mode) <b>[ *not yet implemented ]</b></dt>
<dd>

</dd>
<dt id="globepan-:-evenly-distribute-panning-across-panorama-0-1-accross-all-channels"><b>globepan</b> : evenly distribute panning across panorama 0-1 accross all channels</dt>
<dd>

</dd>
<dt id="setff-:-set-servers-fanning-factor-distance-between-serial-OSC-monitoring-request-somewhere-between-2-and-6-default-3-::-the-serial-monitoring-requests-fader-pan-get-distributed-after-the-following-formula"><b>setff</b> : set server&#39;s fanning factor (distance between serial OSC monitoring request, somewhere between 2 and 6, default 3 ) :: the serial monitoring requests (fader, pan) get distributed after the following formula:</dt>
<dd>

</dd>
<dt id="setmode-:-set-servers-monitoring-mode-auto-mirror-coarse-.-See-Two-main-server-side-monitoring-modes-below"><b>setmode</b> : set server&#39;s monitoring mode (auto, mirror, coarse). See &#39;Two main server-side monitoring modes&#39; below.</dt>
<dd>

<dl>

<dt id="fader-:-ch-FF-2-msec-DELAY"><b>fader</b> : (&lt;ch&gt; * &lt;FF&gt; * 2) msec DELAY</dt>
<dd>

</dd>
<dt id="pan-:-ch-FF-msec-DELAY"><b>pan</b> : (&lt;ch&gt; * &lt;FF&gt;) msec DELAY</dt>
<dd>

</dd>
</dl>

</dd>
</dl>

<h1 id="INTERNAL-CLIENT--COMMANDS"><b>INTERNAL CLIENT- COMMANDS</b></h1>

<p>These are client- (console) initiated</p>

<dl>

<dt id="airmix-cinit-bang-client-signalizing-server-their-own-loadbang-and-querying-for-initial-parameters-such-as-number-of-channels-airdir-etc.-This-request-is-handled-separately-on-air-coremixer-input">/airmix/cinit/ bang =&gt; client signalizing server their own loadbang and querying for initial parameters such as number of channels, airdir etc. This request is handled separately on air-coremixer input.</dt>
<dd>

</dd>
</dl>

<h1 id="AIRMON-::-AIR-CORE-MONITORING-OSC-COMMAND-PROTOCOL">AIRMON :: AIR CORE MONITORING OSC COMMAND PROTOCOL</h1>

<h2 id="MONITORING-TACTICS">MONITORING TACTICS</h2>

<p>Serves dispatching information about the mixer state to all subordinated (remote) web client subjects. While the data, dispatched on momentary basis, does not represent a problem regarding the OSC traffic demands, all continuous data types, such as fader pan etc, represent a challenge. Air engine will internally handle such types by the usage of signal-level streaming, therefore monitoring can be done using 3 different tactics:</p>

<dl>

<dt id="A-request-:-whole-request-for-instance:-fader-.5-3000-sin-6000-is-transfered-copied-from-the-airmix-OSC-input-to-the-web-clients-and-clients-themselves-will-take-care-about-rendering-itself-from-begining-to-end.-Not-only-gpp-airliner-directive-but-also-timer-requests-can-be-given-this-way"><b>A request</b> : whole <b>request</b> (for instance: fader .5 3000 sin 6000) is transfered (copied from the airmix OSC input) to the web clients and clients themselves will take care about rendering itself, from begining to end. Not only <b>gpp-airliner</b> directive, but also timer requests can be given this way.</dt>
<dd>

</dd>
<dt id="B-snapshot-:-current-state-of-controller-transferred-on-periodical-basis-metronome-pulse-.-Intermediate-request-data-is-sent-using-relatively-low-frequency-in-order-to-avoid-OSC-wire-overheads"><b>B snapshot</b> : current state of controller transferred on periodical basis (metronome pulse). Intermediate request data is sent using relatively low frequency in order to avoid OSC wire overheads</dt>
<dd>

</dd>
<dt id="C-contour-:-this-tactics-is-actually-a-modification-of-snapshot-tactics-but-will-only-send-snapshot-to-the-client-s-when-RF-request_fulfilled-signal-on-the-respected-controller-is-broadcast-this-is-called-VR-value_reached-also-provided-by-gpp-airliner-.-So-instead-of-metronome-pulse-the-initiative-for-broadcasting-snapshot-is-based-on-reaching-controllers-border-states.-All-intermediate-request-data-is-ignored.-This-tactics-alone-can-be-used-for-lo-bandwidth-cases-but-also-to-complement-tactics-A-and-B.-With-the-A-tactics-it-can-help-assure-that-the-final-state-is-obeyed-regardless-of-potential-server-client-desync.-With-the-B-tactics-it-can-assure-that-the-border-state-information-is-delivered-exactly-in-time-even-if-the-servers-snapshot-heartbeat-is-low"><b>C contour</b> : this tactics is actually a modification of <b>snapshot</b> tactics, but will only send <b>snapshot</b> to the client(s) when <b>RF (request_fulfilled)</b> signal on the respected controller is broadcast (this is called <b>VR (value_reached)</b>, also provided by gpp-airliner~). So instead of metronome pulse, the initiative for broadcasting <b>snapshot</b> is based on reaching controllers&#39; border states. All intermediate request data is ignored. This tactics alone can be used for lo-bandwidth cases, but also to complement tactics <b>A</b> and <b>B</b>. With the <b>A</b> tactics, it can help assure that the final state is obeyed regardless of potential server/client desync. With the <b>B</b> tactics it can assure that the border state information is delivered exactly in time, even if the server&#39;s snapshot heartbeat is low.</dt>
<dd>

</dd>
</dl>

<h2 id="OSC-CONTROLLER-MAP">OSC CONTROLLER MAP</h2>

<h3 id="MONITORING-TACTICS1">MONITORING TACTICS:</h3>

<dl>

<dt id="A.-REQUEST-::-airmon-request-ch-controller-request-params-any-kind-of-user-request-as-such-copied-directly-from-the-OSC-input-for-each-respective-controller-such-as"><b>A. REQUEST</b> :: /airmon/request/&lt;ch&gt;/&lt;controller&gt; &lt;request params&gt; =&gt; any kind of user-request as such, copied directly from the OSC input for each respective controller, such as:</dt>
<dd>

<dl>

<dt id="airmon-request-ch-fader-airliner-params">/airmon/request/&lt;ch&gt;/<b>fader</b> &lt;airliner~ params&gt;</dt>
<dd>

</dd>
<dt id="airmon-request-ch-pan-airliner-params">/airmon/request/&lt;ch&gt;/<b>pan</b> &lt;airliner~ params&gt;</dt>
<dd>

</dd>
<dt id="pod">(...)</dt>
<dd>

</dd>
</dl>

</dd>
<dt id="A2.-VIRTUAL-REQUEST"><b>A2. VIRTUAL REQUEST</b></dt>
<dd>

<p>A request assembled by the server engine (not passed by the user) in order to encapsule bandwidth-demanding movement to be rendered by the client engine, such as:</p>

<dl>

<dt id="airmon-request-ch-timer-type-start-stop-initial_timing_ms-display-timer-where-type-can-be-play-or-record">/airmon/request/&lt;ch&gt;/<b>timer</b>/&lt;type&gt; [start|stop] [initial_timing_ms]? =&gt; <b>display</b> timer, where &lt;type&gt; can be &quot;play&quot; or &quot;record&quot;</dt>
<dd>

</dd>
</dl>

<dl>

<dt id="B.-SNAPSHOT-::-airmon-snapshot-ch-controller-controller-state-at-the-very-moment"><b>B. SNAPSHOT</b> :: /airmon/snapshot/&lt;ch&gt;/&lt;controller&gt; =&gt; <b>controller</b> state at the very moment</dt>
<dd>

</dd>
<dt id="C.-CONTOUR-::-airmon-contour-ch-...-separate-reporting-of-basic-border-states-::-the-point-of-this-tactics-is-to-report-some-basic-params-that-the-client-web-or-pd-can-use-to-render-their-own-movement.-There-are-several-contour-handlers-such-as"><b>C. CONTOUR</b> :: /airmon/contour/&lt;ch&gt;/ ... =&gt; separate reporting of basic border states :: the point of this tactics is to report some basic params that the client (web or pd) can use to render their own movement. There are several &#39;contour handlers&#39;, such as:</dt>
<dd>

</dd>
</dl>

<dl>

<dt id="rf-controller-controller-rf-when-reached-request-fulfilled-reached-destination-boolean-1-yes-0-not-yet-fader-or-pan">... <b>rf</b>/&lt;controller&gt; =&gt; <b>controller</b> rf when reached (request fulfilled =&gt; reached destination boolean (1=yes 0=not yet), fader or pan</dt>
<dd>

</dd>
<dt id="vr-controller-controller-vr-when-rf-reached-value-reached-the-actual-destination-value-triggered-when-reached-fader-or-pan-and-also-play-record-border-states">... <b>vr</b>/&lt;controller&gt; =&gt; <b>controller</b> vr when rf reached (value reached =&gt; the actual destination value triggered when reached, fader or pan, and also play, record (border states)</dt>
<dd>

</dd>
<dt id="ac-controller-controller-ac-active-:-play-record-and-such-things-player-is-active-boolean-1-yes-0-not">... <b>ac</b>/&lt;controller&gt; =&gt; <b>controller</b> ac (active) : play, record and such things =&gt; player is active boolean (1=yes, 0=not)</dt>
<dd>

</dd>
</dl>

<p>*note difference between <b>rf</b> and <b>ac</b> switches: <b>rf</b> policy is negative (= positive when not active) while <b>ac</b> policy is positive (= negative when not active).</p>

</dd>
</dl>

<h3 id="ALL-THE-REST">ALL THE REST</h3>

<p>All data that cannot be ranged into the 3 main monitoring tactics, will be passed via <b>etc</b></p>

<dl>

<dt id="airmon-etc-anyparam-other-data-or-switches-non-policy-classified">/airmon/etc/&lt;anyparam&gt; =&gt; other data or switches, non policy-classified</dt>
<dd>

</dd>
<dt id="airmon-etc-ch-anyparam-other-data-or-switches-non-policy-classified-:-per-track">/airmon/etc/&lt;ch&gt;/&lt;anyparam&gt; =&gt; other data or switches, non policy-classified : per-track</dt>
<dd>

</dd>
</dl>

<p>for instance:</p>

<dl>

<dt id="airmon-etc-ch-filename-current-file-name-distributed-exactly-before-each-play--or-record--request">/airmon/etc/&lt;ch&gt;/filename/ =&gt; current file name distributed exactly before each play- or record- request</dt>
<dd>

</dd>
<dt id="airmon-etc-ch-mute-mute-boolean-for-the-selected-channel">/airmon/etc/&lt;ch&gt;/mute =&gt; mute boolean for the selected channel</dt>
<dd>

</dd>
<dt id="airmon-etc-master-mute-master-mute-boolean-both-channels">/airmon/etc/master/mute =&gt; master mute boolean (both channels)</dt>
<dd>

</dd>
<dt id="airmon-etc-master-rmute-master-mute-boolean-right-channel-only">/airmon/etc/master/rmute =&gt; master mute boolean (right channel only)</dt>
<dd>

</dd>
<dt id="airmon-etc-master-lmute-master-mute-boolean-left-channel-only">/airmon/etc/master/lmute =&gt; master mute boolean (left channel only)</dt>
<dd>

</dd>
</dl>

<h3 id="DIRECT-SYS-PARAMS">DIRECT SYS PARAMS</h3>

<p>System params (internal communication between air-coremix and console, without user interaction) are sent via /sys/ and /syscore/ controllers. <b>/sys/</b> will deliver the messaga to the console frontend (shell that envelopes console-core) and <b>/syscore/</b> will to the console core itself. These params is no thing the end user should be bothered with.</p>

<dl>

<dt id="airmon-sys-CHNUM-number-of-channels-required-by-gpp-air-coremixer-creation-argument---the-console-automatically-resizes-if-the-argument-changes">/airmon/sys/CHNUM/ =&gt; number of channels, required by gpp-air-coremixer creation argument - the console automatically resizes if the argument changes.</dt>
<dd>

</dd>
<dt id="airmon-syscore-AIRDIR-airdir-path-storage-path-itself-stored-as-text">/airmon/syscore/AIRDIR/ =&gt; airdir path storage (path itself stored as text)</dt>
<dd>

</dd>
<dt id="airmon-syscore-SHOW-boolean-show-hide-console">/airmon/syscore/SHOW/ [boolean] =&gt; show / hide console</dt>
<dd>

</dd>
</dl>

<h1 id="TWO-MAIN-SERVER-SIDE-MONITORING-MODES-BASED-ON-DIFFERENT-MONITORING-TACTICS"><b>TWO MAIN SERVER-SIDE MONITORING MODES BASED ON DIFFERENT MONITORING TACTICS</b></h1>

<dl>

<dt id="MIRROR-and-COARSE-::-implementing-contour-and-snapshot-tactics"><b>MIRROR</b> and <b>COARSE</b> :: implementing <b>contour</b> and <b>snapshot</b> tactics:</dt>
<dd>

<dl>

<dt id="MIRROR-:-use-both-tactics-high-bandwidth-and-low-client-capacity-will-report-border-states-and-intermediate-snapshots-according-to-network-capacity-tunable-.-Contour-skeleton-is-used-to-prevent-possible-timing-based-anomalies-especially-with-extremely-lo-frequency-monitoring-heartbeat"><b>MIRROR</b> : use <b>both</b> tactics =&gt; high bandwidth and low client capacity; will report border states and intermediate snapshots according to network capacity (tunable). <b>Contour</b> skeleton is used to prevent possible timing-based anomalies, especially with extremely lo frequency monitoring heartbeat.</dt>
<dd>

</dd>
<dt id="COARSE-:-use-only-contour-tactic-low-bandwidth-and-low-client-capacity-will-only-report-border-crucial-states"><b>COARSE</b> : use <b>only contour tactic</b> =&gt; low bandwidth and low client capacity; will only report border (crucial) states.</dt>
<dd>

</dd>
</dl>

</dd>
<dt id="AUTO-::-use-request-and-snapshot-tactics-client-themselves-will-render-events-this-is-only-safe-when-client-is-capable-of-running-puredata-console.-Suitable-for-very-low-web-bandwidth.-Contour-skeleton-is-used-to-prevent-possible-timing-based-anomalies"><b>AUTO</b> :: use <b>request</b> and <b>snapshot</b> tactics =&gt; client themselves will render events; this is only safe when client is capable of running puredata console. Suitable for very low web bandwidth. <b>Contour</b> skeleton is used to prevent possible timing-based anomalies.</dt>
<dd>

<p>Server can be set to either mode in terms of communicating with its console(s):</p>

<dl>

<dt id="airmix-setmode-mirror-or-airsh-setmode-mirror-::-set-mirroring-mode-contour-snapshot">/airmix/<b>setmode mirror</b> or airsh <b>setmode mirror</b> :: set mirroring mode (contour + snapshot)</dt>
<dd>

</dd>
<dt id="airmix-setmode-coarse-or-airsh-setmode-coarse-::-set-mirroring-mode-with-only-contour-tactics-enabled">/airmix/<b>setmode coarse</b> or airsh <b>setmode coarse</b> :: set mirroring mode with only contour tactics enabled</dt>
<dd>

</dd>
<dt id="airmix-setmode-auto-or-airsh-setmode-auto-::-set-autonomous-mode-all-rendering-based-on-request-tactics-data-vectors">/airmix/<b>setmode auto</b> or airsh <b>setmode auto</b> :: set autonomous mode (all rendering based on request tactics data vectors)</dt>
<dd>

</dd>
<dt id="airmix-lsmode-::-list-currently-selected-monitoring-mode">/airmix/<b>lsmode</b> :: list currently selected monitoring mode</dt>
<dd>

</dd>
</dl>

</dd>
</dl>

<h1 id="AIRSH-EXAMPLES"><b>AIRSH EXAMPLES</b></h1>

<p>airsh m fader 1 2000 sin =&gt; fade complex curve</p>

<p>airsh 1 fader .3 4000 log 2000 =&gt; fade after delay</p>

<p>airsh play file.wav 0:12.345 0:15.012 +1:0.300 =&gt; play a clip after delay</p>

<p>airsh loop file.wav 0:12.345 0:15.012 +1:0.300 =&gt; loop a clip after delay</p>

<p>airsh rec 0:10 0:15 =&gt; record from (abs) time 10 to 15 seconds (5 sec long block)</p>

<h1 id="MON-OSC-PROTOCOL-EXAMPLES"><b>MON OSC PROTOCOL EXAMPLES</b></h1>

<p>/airmon/request/master/lfader/ 1 3000 sin</p>

<p>/airmon/request/master/rfader/ 1 3000 sin</p>

<p>/airmon/request/master/fader/ 1 3000 sin</p>

<p>/airmon/snapshot/1/fader .346567</p>

<p>/airmon/contour/master/rf/lfader 1</p>

<p>/airmon/contour/master/rf/lfader 1</p>

<p>/airmon/contour/3/ac/player 1</p>

<p>/airmon/contour/1/timer/player start 3543 down</p>

<p>/airmon/contour/1/timer/player stop</p>

<p>/airmon/contour/3/timer/recorder start 0 up</p>

<h1 id="AUTHOR"><b>AUTHOR</b></h1>

<p>Gregor Pirs (c)2022 &lt;gregor.pirs@guest.arnes.si&gt;</p>


</body>

</html>


